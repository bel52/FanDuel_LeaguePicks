import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
import json
import os

from app.ai_integration import AIAnalyzer
from app.data_monitor import RealTimeDataMonitor, PlayerUpdate
from app.enhanced_optimizer import EnhancedDFSOptimizer
from app.cache_manager import CacheManager
from app import data_ingestion

logger = logging.getLogger(__name__)

class AutoSwapSystem:
    """Automated player swapping system based on real-time data and AI analysis"""
    
    def __init__(self):
        self.ai_analyzer = AIAnalyzer()
        self.data_monitor = RealTimeDataMonitor()
        self.optimizer = EnhancedDFSOptimizer()
        self.cache_manager = CacheManager()
        
        # Swap configuration
        self.max_swaps_per_day = int(os.getenv("MAX_SWAPS_PER_DAY", "3"))
        self.swap_threshold = 0.6  # Severity threshold for auto-swap
        self.min_projection_change = 2.0  # Minimum projection change to trigger swap
        
        # Tracking
        self.daily_swaps = 0
        self.swap_history = []
        
        # Game timing
        self.early_game_cutoff = None  # Will be set based on schedule
        self.late_game_cutoff = None
    
    async def start_monitoring(self):
        """Start the automated swapping monitoring system"""
        logger.info("Starting automated player swapping system...")
        
        # Initialize game timing
        await self._initialize_game_timing()
        
        # Start monitoring loop
        while True:
            try:
                current_time = datetime.now()
                
                # Check if we should process swaps
                if await self._should_process_swaps(current_time):
                    await self._process_potential_swaps()
                
                # Monitor for inactive players before games
                if await self._should_check_inactives(current_time):
                    await self._process_inactive_players()
                
                # Sleep for 5 minutes between checks
                await asyncio.sleep(300)
                
            except Exception as e:
                logger.error(f"Error in auto-swap monitoring: {e}")
                await asyncio.sleep(60)  # Shorter sleep on error
    
    async def _initialize_game_timing(self):
        """Initialize game timing for swap cutoffs"""
        try:
            # Get current week's game schedule
            # This would integrate with your existing schedule system
            current_time = datetime.now()
            
            # Set default timing (Sunday games)
            self.early_game_cutoff = current_time.replace(
                hour=13, minute=0, second=0, microsecond=0
            )  # 1:00 PM ET
            
            self.late_game_cutoff = current_time.replace(
                hour=16, minute=5, second=0, microsecond=0
            )  # 4:05 PM ET
            
            logger.info(f"Game timing initialized - Early: {self.early_game_cutoff}, Late: {self.late_game_cutoff}")
            
        except Exception as e:
            logger.error(f"Error initializing game timing: {e}")
    
    async def _should_process_swaps(self, current_time: datetime) -> bool:
        """Determine if we should process swaps at current time"""
        
        # Don't swap if we've hit daily limit
        if self.daily_swaps >= self.max_swaps_per_day:
            return False
        
        # Don't swap during games (simplified logic)
        if self.early_game_cutoff and self.late_game_cutoff:
            if self.early_game_cutoff <= current_time <= self.late_game_cutoff:
                return False
        
        # Only swap if auto-swap is enabled
        auto_swap_enabled = os.getenv("AUTO_SWAP_ENABLED", "true").lower() == "true"
        return auto_swap_enabled
    
    async def _should_check_inactives(self, current_time: datetime) -> bool:
        """Check if we should look for inactive player updates"""
        
        # Check inactives 90 minutes before early games
        if self.early_game_cutoff:
            inactive_check_time = self.early_game_cutoff - timedelta(minutes=90)
            return abs((current_time - inactive_check_time).total_seconds()) < 300  # Within 5 minutes
        
        return False
    
    async def _process_potential_swaps(self):
        """Process potential player swaps based on recent updates"""
        
        try:
            # Get recent high-severity updates
            recent_updates = await self.data_monitor.get_recent_updates(hours=2)
            high_severity_updates = [
                update for update in recent_updates 
                if update['severity'] >= self.swap_threshold
            ]
            
            if not high_severity_updates:
                return
            
            # Get current lineup
            current_lineup = await self._get_current_lineup()
            if not current_lineup:
                logger.warning("No current lineup found for auto-swap")
                return
            
            # Check each update for swap potential
            for update in high_severity_updates:
                await self._evaluate_swap_for_update(update, current_lineup)
                
        except Exception as e:
            logger.error(f"Error processing potential swaps: {e}")
    
    async def _process_inactive_players(self):
        """Process inactive player updates and force swaps if needed"""
        
        try:
            # Get recent injury/inactive updates
            recent_updates = await self.data_monitor.get_recent_updates(hours=6)
            inactive_updates = [
                update for update in recent_updates
                if update['update_type'] == 'injury' and update['severity'] >= 0.8
            ]
            
            if not inactive_updates:
                return
            
            current_lineup = await self._get_current_lineup()
            if not current_lineup:
                return
            
            # Force swaps for inactive players
            for update in inactive_updates:
                player_name = update['player_name']
                
                # Check if this player is in our lineup
                lineup_player = next(
                    (p for p in current_lineup if p['name'].lower() == player_name.lower()), 
                    None
                )
                
                if lineup_player:
                    logger.warning(f"Inactive player detected in lineup: {player_name}")
                    await self._force_player_swap(lineup_player, "Player inactive")
                    
        except Exception as e:
            logger.error(f"Error processing inactive players: {e}")
    
    async def _evaluate_swap_for_update(self, update: Dict, current_lineup: List[Dict]):
        """Evaluate if an update should trigger a player swap"""
        
        player_name = update['player_name']
        update_type = update['update_type']
        severity = update['severity']
        
        # Find if this player is in our current lineup
        lineup_player = next(
            (p for p in current_lineup if p['name'].lower() == player_name.lower()), 
            None
        )
        
        if not lineup_player:
            return  # Player not in our lineup
        
        # Calculate potential impact
        current_projection = lineup_player['proj_points']
        
        # Estimate new projection based on update
        if update_type == 'injury':
            new_projection = current_projection * (1 - severity)
        elif update_type == 'weather':
            new_projection = current_projection * (1 - severity * 0.3)
        else:
            new_projection = current_projection * (1 - severity * 0.5)
        
        projection_change = current_projection - new_projection
        
        # Only swap if change is significant
        if projection_change >= self.min_projection_change:
            logger.info(f"Evaluating swap for {player_name}: {current_projection:.1f} â†’ {new_projection:.1f}")
            await self._execute_player_swap(lineup_player, update, new_projection)
    
    async def _execute_player_swap(
        self, 
        player_to_replace: Dict, 
        trigger_update: Dict,
        new_projection: float
    ):
        """Execute a player swap"""
        
        try:
            # Get available players for the position
            current_data = data_ingestion.load_weekly_data()
            if current_data is None:
                logger.error("No player data available for swap")
                return
            
            position = player_to_replace['position']
            salary_budget = player_to_replace['salary']
            team_to_avoid = player_to_replace['team']  # Avoid same team for diversification
            
            # Find replacement candidates
            candidates = current_data[
                (current_data['POS'] == position) & 
                (current_data['SALARY'] <= salary_budget * 1.1) &  # Allow 10% salary increase
                (current_data['TEAM'] != team_to_avoid)
            ].copy()
            
            if candidates.empty:
                logger.warning(f"No replacement candidates found for {player_to_replace['name']}")
                return
            
            # Calculate value scores for candidates
            candidates['value_score'] = candidates['PROJ PTS'] / (candidates['SALARY'] / 1000)
            
            # Use AI to evaluate best replacement
            best_replacement = await self._ai_select_replacement(
                player_to_replace, candidates, trigger_update
            )
            
            if best_replacement is not None:
                await self._confirm_and_execute_swap(
                    player_to_replace, best_replacement, trigger_update
                )
            
        except Exception as e:
            logger.error(f"Error executing swap for {player_to_replace['name']}: {e}")
    
    async def _ai_select_replacement(
        self,
        player_to_replace: Dict,
        candidates: Any,  # DataFrame
        trigger_update: Dict
    ) -> Optional[Dict]:
        """Use AI to select the best replacement player"""
        
        try:
            # Format candidates for AI analysis
            top_candidates = candidates.nlargest(5, 'value_score')
            
            candidate_info = []
            for idx, candidate in top_candidates.iterrows():
                candidate_info.append({
                    'name': candidate['PLAYER NAME'],
                    'team': candidate['TEAM'],
                    'salary': candidate['SALARY'],
                    'projection': candidate['PROJ PTS'],
                    'value_score': candidate['value_score']
                })
            
            #

import os
import logging
from contextlib import asynccontextmanager

from fastapi import FastAPI, Query, HTTPException
from fastapi.responses import JSONResponse, PlainTextResponse

try:
    # Don't crash if these modules changeâ€”import lazily in handlers too.
    from app.config import settings
except Exception:
    class _S:
        # Minimal safe defaults if config import fails
        input_dir = "data/input"
        output_dir = "data/output"
        logs_dir = "logs"
        log_level = "INFO"
    settings = _S()  # type: ignore

logger = logging.getLogger("app.main")
logging.basicConfig(level=getattr(logging, getattr(settings, "log_level", "INFO").upper(), logging.INFO))

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Starting FanDuel DFS Optimizer...")
    # Ensure dirs exist, even if config is minimal
    for d in [getattr(settings, "input_dir", "data/input"),
              getattr(settings, "output_dir", "data/output"),
              getattr(settings, "logs_dir", "logs")]:
        os.makedirs(d, exist_ok=True)
    yield

app = FastAPI(
    title="DFS Optimizer",
    version="0.1.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json",
    lifespan=lifespan,
)

@app.get("/", include_in_schema=False, response_class=PlainTextResponse)
def root():
    return "DFS Optimizer is alive. See /health, /schedule, /optimize_text, and /docs."

@app.get("/health")
def health():
    # Always return JSON
    info = {
        "status": "ok",
        "input_dir": getattr(settings, "input_dir", "data/input"),
        "output_dir": getattr(settings, "output_dir", "data/output"),
        "logs_dir": getattr(settings, "logs_dir", "logs"),
    }
    # Try to count players if data_ingestion is present, but don't fail health
    try:
        from app import data_ingestion as di  # type: ignore
        if hasattr(di, "load_player_pool"):
            pool = di.load_player_pool()
            info["players"] = len(pool)
    except Exception as e:
        logger.warning("health: optional player count failed: %s", e)
        info["players"] = None
        info["note"] = "player count unavailable"
    return JSONResponse(info)

@app.get("/schedule")
def schedule():
    # Return VALID JSON (even if you haven't implemented schedule yet)
    try:
        prov = getattr(settings, "schedule_provider", "none")
        tz = getattr(settings, "timezone", "UTC")
        return JSONResponse({"provider": prov, "timezone": tz, "games": []})
    except Exception as e:
        # Still return JSON, not plain text
        return JSONResponse({"provider": "unknown", "timezone": "UTC", "games": [], "error": str(e)})

@app.get("/optimize_text", response_class=PlainTextResponse)
def optimize_text(width: int = Query(100, ge=40, le=200)):
    """
    Returns a text layout of the optimal lineup(s).
    Falls back gracefully if app.optimization.optimize_text is not available.
    """
    try:
        from app import optimization as opt  # import inside for robustness
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"optimization module unavailable: {e}")

    # Prefer a dedicated text function if present
    if hasattr(opt, "optimize_text"):
        try:
            return opt.optimize_text(width=width)  # type: ignore
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"optimize_text failed: {e}")

    # Fallbacks: try generic optimize() and stringify
    for cand in ("optimize", "run_optimization", "build_lineups"):
        if hasattr(opt, cand):
            try:
                result = getattr(opt, cand)()  # type: ignore
                return str(result)
            except Exception as e:
                raise HTTPException(status_code=500, detail=f"{cand} failed: {e}")

    # Nothing usable found
    raise HTTPException(status_code=501, detail="No optimization entrypoint found (optimize_text/optimize).")

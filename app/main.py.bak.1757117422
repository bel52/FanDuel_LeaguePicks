import os
import logging
from contextlib import asynccontextmanager
from typing import Optional

from fastapi import FastAPI, Query
from fastapi.responses import PlainTextResponse, JSONResponse

# NOTE: settings import should remain, but we won't touch non-existent attributes
try:
    from app.config import settings  # uses pydantic-settings now
except Exception as e:
    class _S:
        log_level = "INFO"
        input_dir = "data/input"
        output_dir = "data/output"
        logs_dir = "logs"
    settings = _S()

logger = logging.getLogger("app.main")
logging.basicConfig(level=getattr(logging, str(settings.log_level).upper(), logging.INFO))

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Make sure directories exist if present on settings (fallbacks above handle missing attrs)
    for attr, default in [("input_dir","data/input"), ("output_dir","data/output"), ("logs_dir","logs")]:
        try:
            path = getattr(settings, attr, default)
            if path:
                os.makedirs(path, exist_ok=True)
        except Exception as e:
            logger.warning("Could not ensure directory for %s: %s", attr, e)
    logger.info("Starting FanDuel DFS Optimizer...")
    yield

app = FastAPI(
    title="DFS Optimizer",
    version="0.1.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json",
    lifespan=lifespan,
)

@app.get("/", response_class=PlainTextResponse, include_in_schema=False)
def root():
    return "DFS Optimizer is alive. See /health and /docs."

@app.get("/health", response_class=PlainTextResponse)
def health():
    # keep plain-text OK so your existing checks continue working
    return "OK"

@app.get("/schedule")
def schedule():
    # Stub: returns empty schedule for now, so it's valid JSON
    try:
        tz = getattr(settings, "timezone", "UTC")
    except Exception:
        tz = "UTC"
    return {"timezone": tz, "games": []}

@app.get("/optimize_text", response_class=PlainTextResponse)
def optimize_text(width: Optional[int] = Query(default=100, ge=40, le=200)):
    """
    Human-readable lineup output. 'width' controls table width (40-200).
    """
    try:
        # Import inside the handler so the server can still boot even if optimization stack has issues
        from app.optimization import optimize_text as _run
    except Exception as e:
        logger.exception("Optimization module import failed")
        return PlainTextResponse(f"Optimization unavailable: {e}", status_code=500)

    try:
        result = _run(width=width or 100)
        if not isinstance(result, str):
            result = str(result)
        return result
    except Exception as e:
        logger.exception("Optimization failed")
        return PlainTextResponse(f"Optimization error: {e}", status_code=500)

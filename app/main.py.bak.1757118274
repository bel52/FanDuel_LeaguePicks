# app/main.py
import os
import logging
from contextlib import asynccontextmanager

from fastapi import FastAPI, Query
from fastapi.responses import JSONResponse, PlainTextResponse

# Try to import settings, but don't let it kill the app if it fails
try:
    from app.config import settings  # type: ignore
except Exception:
    class _SettingsFallback:
        input_dir = "data/input"
        output_dir = "data/output"
        logs_dir = "logs"
        log_level = "INFO"
        timezone = "UTC"
    settings = _SettingsFallback()  # type: ignore

logger = logging.getLogger("app.main")
logging.basicConfig(
    level=getattr(logging, getattr(settings, "log_level", "INFO").upper(), logging.INFO)
)

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Starting FanDuel DFS Optimizer...")
    # Ensure expected dirs exist even if config is minimal
    for d in [
        getattr(settings, "input_dir", "data/input"),
        getattr(settings, "output_dir", "data/output"),
        getattr(settings, "logs_dir", "logs"),
    ]:
        os.makedirs(d, exist_ok=True)
    yield

app = FastAPI(
    title="DFS Optimizer",
    version="0.1.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json",
    lifespan=lifespan,
)

@app.get("/", include_in_schema=False, response_class=PlainTextResponse)
def root():
    return "DFS Optimizer is alive. See /health, /schedule, /optimize_text, and /docs."

@app.get("/health")
def health():
    """Always JSON; includes basic diagnostics, never raises."""
    info = {
        "status": "ok",
        "timezone": getattr(settings, "timezone", "UTC"),
        "dirs": {
            "input": getattr(settings, "input_dir", "data/input"),
            "output": getattr(settings, "output_dir", "data/output"),
            "logs": getattr(settings, "logs_dir", "logs"),
        },
    }
    # Try to count players, but don't fail if code/data aren't present
    try:
        from app.data_ingestion import load_players  # your file uses load_players()
        try:
            pool = load_players()
            info["players"] = len(pool)
        except Exception as e:
            info["status"] = "degraded"
            info["players_error"] = str(e)
    except Exception:
        info["players"] = None
        info["note"] = "app.data_ingestion.load_players not available"
    return JSONResponse(info)

@app.get("/schedule")
def schedule():
    """Return JSON stub so `| python3 -m json.tool` succeeds."""
    tz = getattr(settings, "timezone", "UTC")
    return JSONResponse({"timezone": tz, "games": []})

@app.get("/optimize_text", response_class=PlainTextResponse)
def optimize_text_endpoint(
    width: int = Query(100, ge=20, le=200, description="Output wrap width for text report"),
):
    """
    Plain-text endpoint. If the real optimizer exists, use it; otherwise return a helpful message.
    """
    # Try the real optimizer
    try:
        from app.optimization import optimize_text  # expected signature: (width:int)->str
        try:
            result = optimize_text(width=width)
            if not isinstance(result, str):
                result = str(result)
            return result
        except Exception as e:
            logger.exception("optimize_text raised")
            return f"Optimization error: {e}"
    except Exception:
        # Fallback message keeps the endpoint working as plaintext
        return (
            "Optimizer not available. Export a function `optimize_text(width:int)->str` "
            "from app/optimization.py, then rebuild. Example usage: GET /optimize_text?width=110"
        )
